# import the library for getting API
import requests

# import the library for accessing environment variables
import os

# import library time to give time for retrying to connect to the API
import time

# import streamlit to create widgets to be displayed in the main app
import streamlit as st


# load the PONS API KEY from the keys.env to a string variable used for calling the API
api_key = st.secrets["API_KEY"]

def get_the_object_name(image):
	# define the API url
	url = "https://api-inference.huggingface.co/models/google/vit-base-patch16-224"
	# define the headers for authorization of access to the API
	headers = {'Accept': '*/*',
 'Accept-Encoding': 'identity, deflate, compress, gzip',
 'Authorization': f"Bearer {api_key}",
 'User-Agent': 'python-requests/0.12.1'}
	# prepare the image to the format readable by API
	image = image.read()
	# set this variable as empty string which will later receive the status message from API
	api_status_object_analysis = ""
	# set this variable as 0 (no request to API made yet)
	api_object_analysis_try = 0

	# while API won't return a successful response and the number of retries does not reach 10, keep retrying
	while api_status_object_analysis != "<Response [200]>" and api_object_analysis_try != 10:
		api_status_object_analysis = requests.post(url, headers=headers, data=image)
		# make the format as string so it can be noticed by the while loop condition
		api_status_object_analysis = str(api_status_object_analysis)
		print(api_status_object_analysis)
		time.sleep(2)
		# increase the number of attempts to reach API by 1
		api_object_analysis_try += 1

	# if the API connection was successful, do the actual job and get the translation from a working API
	if api_object_analysis_try != 10:
		# get the response using the URL, headers, and image data; convert the response into a readable format
		word = requests.post(url, headers=headers, data=image).json()
		# get the most probable object on the photo according to the model and the label of it
		print(word)
		word = word[0]["label"]
		# if there are multiple words identified on the picture (indicated by comma)
		if "," in word:
			# split the words and create a list
			word = word.split(",")
			# take the first item of the list (first word)
			word = word[0]
		# if there is only one word, nothing else needs to happen
		else:
			pass
		return word
	# # if the API connection failed, return error to the process function
	else:
		return "ERROR"


def get_the_translation(text):
	# prepare the translation text using the input from the object identifier
	translation_input = f"the {text}, the {text}s"

	# define the API url
	url = "https://api-inference.huggingface.co/models/facebook/wmt19-en-de"
	# define the headers for authorization of access to the API
	headers = {"Authorization": f"Bearer {api_key}"}

	# set this variable as empty string which will later receive the status message from API
	api_status_translation = ""
	# set this variable as 0 (no request to API made yet)
	api_status_translation_try = 0

	# while API won't return a successful response and the number of retries does not reach 10, keep retrying
	while api_status_translation != "<Response [200]>" and api_status_translation_try != 10:
		api_status_translation = requests.post(url, headers=headers, json={
			"inputs": translation_input,
		})
		# make the format as string so it can be noticed by the while loop condition
		api_status_translation = str(api_status_translation)
		print(api_status_translation)
		time.sleep(2)
		# increase the number of attempts to reach API by 1
		api_status_translation_try += 1

	# if the API connection was successful, do the actual job and get the translation from a working API
	if api_status_translation_try != 10:
		# load the response from the translation model
		translation = requests.post(url, headers=headers, json={
			"inputs": translation_input,
		}).json()
		# get the dictionary item from the list generated by the API
		translation = translation[0]
		# get the string value from the translation_text parameter
		translation = translation["translation_text"]
		# return the translation and also the original input
		return translation, translation_input
	# if the API connection failed, return error to the process function
	else:
		return "ERROR"


# put the functions for analysing objects and then translating them into German together
def process(images):
	# define a variable which will store the list of translations for each image uploaded
	list_of_translations = []
	# define a variable which stores the length of the images for main app to know how many items
	# need to be displayed
	number_of_items = None

	# define percentage as 0 (will be used to display the progress of the function in st.status)
	percentage = 0
	# do everything within a with st.status function to enable display the progress of function to the user
	with st.status(f"Processing your images ({percentage}% completed)", expanded=True) as status:
		# define percentage increase as 100 divided by the number of uploaded images and this divided by two
		# (each image has two steps)
		percentage_increase = round((100 / len(images))/2)
		# for as many images as the user uploaded
		for i in range(len(images)):
			# Check if there are no errors in the list of translations yet. If not, continue.
			if "ERROR" not in list_of_translations:
				# get the image you are processing from the list of uploaded images
				image = images[i]
				# add another percentage increase
				percentage = percentage + percentage_increase
				# display the current percentage state in st.status (after successful step)
				status.update(label=f"Processing your images ({percentage-percentage_increase}% completed)")
				# write to the status that the object is being identified on the image (first part)
				st.write(f"ðŸ”Ž Identifying the object on the image *{image.name}*")
				# get the object name from the picture and assign it to a variable object_name
				object_name = get_the_object_name(image)
				# if the API works correctly and does not return an error
				if object_name != "ERROR":
					# add another percentage increase (after successful step)
					percentage = percentage + percentage_increase
					# display the current percentage state in st.status
					status.update(label=f"Processing your images ({percentage-percentage_increase}% completed)")
					# write to the status that the translation is being received (second part)
					st.write(f"ðŸ“° Fetching the German name of the object on the image *{image.name}*")
					# pass object_name to the translation function and also get the original value
					translation, original_input = get_the_translation(object_name)
					# if the API works and does not return an error
					if translation != "ERROR":
						# assign the translation and the original input to the list of translations
						# to be used in the main app
						list_of_translations.append([translation, original_input])
					else:
						# otherwise say this item returned an error (due to API error)
						list_of_translations.append("ERROR")
				# otherwise say this item returned an error (due to API error)
				else:
					list_of_translations.append("ERROR")

		# if there was no error in the process
		if "ERROR" not in list_of_translations:
			# set the number of items to the actual number of images
			number_of_items = len(images)
		else:
			# set the number of items to 0 so the main app does not show incomplete and error-containing result
			number_of_items = 0
			# display an error for 7 seconds informing the user that API connection failed
			with st.empty():
				for i in range(7):
					st.error('The connection to the API which processes your image failed. Please refresh and try again.',
							 icon="ðŸš¨")
					time.sleep(1)
				st.empty()
		# change the status information to complete
		status.update(label="Images processed!", state="complete", expanded=False)

	# return the list of translations and number of items to the main app as session states
	# as they are not rewritten once the app reloads like variables
	# (for example after an interaction with a widget) and are valid for the whole session
	st.session_state["result"] = list_of_translations
	st.session_state["number_of_items"] = number_of_items

	st.session_state["no_menu_changing"] = False

